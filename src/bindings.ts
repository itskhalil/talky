
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async changeFontSizeSetting(size: FontSize) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_font_size_setting", { size }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeStartHiddenSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_start_hidden_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutostartSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_autostart_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeTranslateToEnglishSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_translate_to_english_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSelectedLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_selected_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDebugModeSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_debug_mode_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeExperimentalEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_experimental_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessBaseUrlSetting(providerId: string, baseUrl: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_base_url_setting", { providerId, baseUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessApiKeySetting(providerId: string, apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_api_key_setting", { providerId, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessModelSetting(providerId: string, model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_model_setting", { providerId, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPostProcessModels(providerId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_post_process_models", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addPostProcessPrompt(name: string, prompt: string) : Promise<Result<LLMPrompt, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_post_process_prompt", { name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updatePostProcessPrompt(id: string, name: string, prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_post_process_prompt", { id, name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deletePostProcessPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_post_process_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessSelectedPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_selected_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCustomWords(words: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_custom_words", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getWordSuggestions() : Promise<WordSuggestion[]> {
    return await TAURI_INVOKE("get_word_suggestions");
},
async approveWordSuggestion(word: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("approve_word_suggestion", { word }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dismissWordSuggestion(word: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dismiss_word_suggestion", { word }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addWordSuggestion(word: string, sessionTitle: string, sessionId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_word_suggestion", { word, sessionTitle, sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeWordSuggestionsEnabled(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_word_suggestions_enabled", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSpeakerEnergyThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_speaker_energy_threshold_setting", { threshold }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_app_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUpdateChecksSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_update_checks_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setChatProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_chat_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeChatModelSetting(providerId: string, model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_chat_model_setting", { providerId, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchChatModels(providerId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_chat_models", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeCopyAsBulletsSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_copy_as_bullets_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async triggerUpdateCheck() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_update_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelOperation() : Promise<void> {
    await TAURI_INVOKE("cancel_operation");
},
async writeChatDebugLog(lines: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_chat_debug_log", { lines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setLogLevel(level: LogLevel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_log_level", { level }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_log_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openAppDataDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_app_data_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current user data directory path.
 * Returns the custom path if set, otherwise the default app data directory.
 */
async getUserDataDirectory() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_user_data_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a custom data directory is configured.
 */
async hasCustomDataDirectory() : Promise<boolean> {
    return await TAURI_INVOKE("has_custom_data_directory");
},
/**
 * Set a new data directory and optionally migrate existing data.
 * Returns true if migration was successful, false if the directory couldn't be used.
 * After calling this, the app should be restarted for changes to take effect.
 */
async setDataDirectory(newPath: string | null, migrateData: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_data_directory", { newPath, migrateData }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open the current user data directory in Finder/Explorer.
 */
async openUserDataDirectory() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_user_data_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if Apple Intelligence is available on this device.
 * Called by the frontend when the user selects Apple Intelligence provider.
 */
async checkAppleIntelligenceAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("check_apple_intelligence_available");
},
/**
 * Check if Ollama is running and available at the given base URL.
 * Returns the list of installed model names if available, empty vec if not running.
 */
async checkOllamaAvailable(baseUrl: string | null) : Promise<string[]> {
    return await TAURI_INVOKE("check_ollama_available", { baseUrl });
},
async getAvailableModels() : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getModelInfo(modelId: string) : Promise<Result<ModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_info", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setActiveModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCurrentModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTranscriptionModelStatus() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_transcription_model_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isModelLoading() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_model_loading") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsAvailable() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_available") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsOrDownloads() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_or_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecommendedFirstModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recommended_first_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableMicrophones() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_microphones") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableOutputDevices() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_output_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedOutputDevice(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_output_device", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedOutputDevice() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_output_device") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setClamshellMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_clamshell_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getClamshellMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_clamshell_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isRecording() : Promise<boolean> {
    return await TAURI_INVOKE("is_recording");
},
/**
 * Triggers the system audio permission request by briefly starting the audio tap.
 * This is used during onboarding to request the "System Audio Recording Only" permission.
 */
async requestSystemAudioPermission() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("request_system_audio_permission") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setModelUnloadTimeout(timeout: ModelUnloadTimeout) : Promise<void> {
    await TAURI_INVOKE("set_model_unload_timeout", { timeout });
},
async getModelLoadStatus() : Promise<Result<ModelLoadStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_load_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadModelManually() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unload_model_manually") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHistoryEntries() : Promise<Result<HistoryEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_history_entries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async toggleHistoryEntrySaved(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_history_entry_saved", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryEntry(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_entry", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateHistoryLimit(limit: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_history_limit", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateRecordingRetentionPeriod(period: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_recording_retention_period", { period }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the Mac is a laptop by detecting battery presence
 * 
 * This uses pmset to check for battery information.
 * Returns true if a battery is detected (laptop), false otherwise (desktop)
 */
async isLaptop() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_laptop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new session (Note) without starting recording.
 */
async startSession(title: string | null) : Promise<Result<Session, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_session", { title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start recording within an existing session.
 */
async startSessionRecording(sessionId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_session_recording", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop recording but keep the session open.
 */
async stopSessionRecording(sessionId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_session_recording", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Reactivate a completed session so it can record again.
 */
async reactivateSession(sessionId: string) : Promise<Result<Session, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reactivate_session", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async endSession() : Promise<Result<Session | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("end_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchSessions(query: string) : Promise<Result<Session[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_sessions", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessions() : Promise<Result<Session[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sessions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSession(sessionId: string) : Promise<Result<Session | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_session", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessionTranscript(sessionId: string) : Promise<Result<TranscriptSegment[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_session_transcript", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getActiveSession() : Promise<Result<Session | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteSession(sessionId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_session", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateSessionTitle(sessionId: string, title: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_session_title", { sessionId, title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMeetingNotes(sessionId: string) : Promise<Result<MeetingNotes | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_meeting_notes", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveMeetingNotes(sessionId: string, summary: string | null, actionItems: string | null, decisions: string | null, userNotes: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_meeting_notes", { sessionId, summary, actionItems, decisions, userNotes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveUserNotes(sessionId: string, notes: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_user_notes", { sessionId, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveEnhancedNotes(sessionId: string, notes: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_enhanced_notes", { sessionId, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getUserNotes(sessionId: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_user_notes", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async generateSessionSummary(sessionId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_session_summary", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessionSummary(sessionId: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_session_summary", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Force-flush any buffered audio through the transcription pipeline.
 * Called before chat so the transcript is as up-to-date as possible.
 */
async flushPendingAudio(sessionId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("flush_pending_audio", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createFolder(name: string, color: string | null) : Promise<Result<Folder, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_folder", { name, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateFolder(folderId: string, name: string, color: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_folder", { folderId, name, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteFolder(folderId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_folder", { folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFolders() : Promise<Result<Folder[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_folders") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async moveSessionToFolder(sessionId: string, folderId: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("move_session_to_folder", { sessionId, folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessionsByFolder(folderId: string | null) : Promise<Result<Session[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sessions_by_folder", { folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createTag(name: string, color: string | null) : Promise<Result<Tag, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_tag", { name, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateTag(tagId: string, name: string, color: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_tag", { tagId, name, color }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteTag(tagId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_tag", { tagId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTags() : Promise<Result<Tag[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_tags") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addTagToSession(sessionId: string, tagId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_tag_to_session", { sessionId, tagId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeTagFromSession(sessionId: string, tagId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_tag_from_session", { sessionId, tagId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessionTags(sessionId: string) : Promise<Result<Tag[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_session_tags", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSessionTags(sessionId: string, tagIds: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_session_tags", { sessionId, tagIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSessionsByTag(tagId: string) : Promise<Result<Session[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sessions_by_tag", { tagId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AppSettings = { 
/**
 * Custom directory for user data (sessions.db, history.db).
 * When None, uses the default app data directory.
 * This allows storing data in iCloud Drive or other backup-friendly locations.
 */
data_directory?: string | null; font_size?: FontSize; start_hidden?: boolean; autostart_enabled?: boolean; update_checks_enabled?: boolean; selected_model?: string; selected_microphone?: string | null; clamshell_microphone?: string | null; selected_output_device?: string | null; translate_to_english?: boolean; selected_language?: string; debug_mode?: boolean; hide_cloud_models?: boolean; log_level?: LogLevel; custom_words?: string[]; model_unload_timeout?: ModelUnloadTimeout; word_correction_threshold?: number; history_limit?: number; recording_retention_period?: RecordingRetentionPeriod; post_process_enabled?: boolean; post_process_provider_id?: string; post_process_providers?: PostProcessProvider[]; post_process_api_keys?: Partial<{ [key in string]: string }>; post_process_models?: Partial<{ [key in string]: string }>; post_process_prompts?: LLMPrompt[]; post_process_selected_prompt_id?: string | null; app_language?: string; experimental_enabled?: boolean; chat_provider_id?: string; chat_models?: Partial<{ [key in string]: string }>; copy_as_bullets_enabled?: boolean; word_suggestions?: WordSuggestion[]; dismissed_suggestions?: string[]; word_suggestions_enabled?: boolean; speaker_energy_threshold?: number }
export type AudioDevice = { index: string; name: string; is_default: boolean }
export type EngineType = "Whisper" | "Parakeet" | "Moonshine"
export type Folder = { id: string; name: string; color: string | null; sort_order: number; created_at: number }
export type FontSize = "small" | "medium" | "large"
export type HistoryEntry = { id: number; file_name: string; timestamp: number; saved: boolean; title: string; transcription_text: string; post_processed_text: string | null; post_process_prompt: string | null }
export type LLMPrompt = { id: string; name: string; prompt: string }
export type LogLevel = "trace" | "debug" | "info" | "warn" | "error"
export type MeetingNotes = { id: number; session_id: string; summary: string | null; action_items: string | null; decisions: string | null; user_notes: string | null; enhanced_notes: string | null; created_at: number; updated_at: number }
export type ModelInfo = { id: string; name: string; description: string; filename: string; url: string | null; size_mb: number; is_downloaded: boolean; is_downloading: boolean; partial_size: number; is_directory: boolean; engine_type: EngineType; accuracy_score: number; speed_score: number }
export type ModelLoadStatus = { is_loaded: boolean; current_model: string | null }
export type ModelUnloadTimeout = "never" | "immediately" | "min_2" | "min_5" | "min_10" | "min_15" | "hour_1" | "sec_5"
export type PostProcessProvider = { id: string; label: string; base_url: string; allow_base_url_edit?: boolean; models_endpoint?: string | null }
export type RecordingRetentionPeriod = "never" | "preserve_limit" | "days_3" | "weeks_2" | "months_3"
export type Session = { id: string; title: string; started_at: number; ended_at: number | null; status: string; folder_id: string | null }
export type Tag = { id: string; name: string; color: string | null }
export type TranscriptSegment = { id: number; session_id: string; text: string; source: string; start_ms: number; end_ms: number; created_at: number }
export type WordSuggestion = { word: string; source_session_title: string; source_session_id: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
